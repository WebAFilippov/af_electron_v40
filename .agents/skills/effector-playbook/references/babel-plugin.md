# Babel plugin

Built-in plugin for babel can be used for ssr and debugging. It inserts a name a Unit,
inferred from variable name and `sid` (Stable IDentifier), computed from the location in the source code.

For example, in case effects without handlers, it improves error messages by
clearly showing in which effect error happened.

```js
import { createEffect } from "effector";

const fetchFx = createEffect();

fetchFx();

// => no handler used in fetchFx
```

Try it

## Usage

In the simplest case, it can be used without any configuration:

```json
// .babelrc
{
  "plugins": ["effector/babel-plugin"]
}
```

## SID

> INFO since: 
>
> [effector 20.2.0](https://changelog.effector.dev/#effector-20-2-0)

Stable hash identifier for events, effects, stores and domains, preserved between environments, to handle client-server
interaction within the same codebase.

The crucial value of sid is that it can be autogenerated by `effector/babel-plugin` with default config, and it will be stable between builds.

> TIP Deep dive explanation: 
>
> If you need the detailed deep-dive explanation about why we need SIDs and how they are used internally, you can find it by following this link

See [example project](https://github.com/effector/effector/tree/master/examples/worker-rpc)

```js
// common.js
import { createEffect } from "effector";

export const getUser = createEffect({ sid: "GET /user" });
console.log(getUsers.sid);
// => GET /user
```

```js
// worker.js
import { getUsers } from "./common.js";

getUsers.use((userID) => fetch(userID));

getUsers.done.watch(({ result }) => {
  postMessage({ sid: getUsers.sid, result });
});

onmessage = async ({ data }) => {
  if (data.sid !== getUsers.sid) return;
  getUsers(data.userID);
};
```

```js
// client.js
import { createEvent } from "effector";
import { getUsers } from "./common.js";

const onMessage = createEvent();

const worker = new Worker("worker.js");
worker.onmessage = onMessage;

getUsers.use(
  (userID) =>
    new Promise((rs) => {
      worker.postMessage({ sid: getUsers.sid, userID });
      const unwatch = onMessage.watch(({ data }) => {
        if (data.sid !== getUsers.sid) return;
        unwatch();
        rs(data.result);
      });
    }),
);
```

## Configuration

### `hmr`

> INFO since: 
>
> [effector 23.4.0](https://changelog.effector.dev/#effector-23.4.0)

Enable Hot Module Replacement (HMR) support to clean up links, subscriptions and side effects managed by Effector. This prevents double-firing of Effects and watchers.

> WARNING Interaction with factories: 
>
> HMR support show best results when all factories in project are properly declared, which help plugin and runtime to know which code to clear on hot updates

#### Formulae

```json
"effector/babel-plugin",
  {
    "hmr": "es"
  }
]
```

* Type: `boolean` | `"es"` | `"cjs"`
  * `true`: Use hmr with auto-detection of target case. Based on [supportsStaticESM](https://babeljs.io/docs/options#caller) babel feature with wide support in bundlers
  * `"es"`: Use `import.meta.hot` HMR API in bundlers that are ESM-compliant, like Vite and Rollup
  * `"cjs"`: Use `module.hot` HMR API in bundlers that rely on CommonJS modules, like Webpack, Next.js or React Native
  * `false`: Disable Hot Module Replacement
* Default: `false`

> INFO In Production: 
>
> When bundling for production, make sure to set the `hmr` option to `false` or remove it to reduce bundle size and improve runtime performance.

### `forceScope`

> INFO since: 
>
> [effector 23.4.0](https://changelog.effector.dev/#effector-23.4.0)

Adds `forceScope` to all hooks from `effector-react`. This prevents mistakes when events called in non-scoped environment.

#### Formulae

```json
"effector/babel-plugin",
  {
    "forceScope": true
  }
```

* Type: `boolean`
  * `true`: Adds `{ forceScope: true }` to hooks like `useUnit`
  * `false`: Do nothing
* Default: `false`

### `importName`

Specifying import name or names to process by plugin. Import should be used in the code as specified.

#### Formulae

```json
[
  "effector/babel-plugin",
  {
    "importName": ["effector"]
  }
]
```

* Type: `string | string[]`
* Default: `['effector', 'effector/compat']`

### `factories`

Accepts an array of module names which exports treat as custom factories, therefore, each function call provides a unique prefix for sids of units inside them. Used to
SSR(Server Side Rendering) and it's not required for client-only application.

> INFO since: 
>
> [effector 21.6.0](https://changelog.effector.dev/#effector-21-6-0)

#### Formulae

```json
[
  "effector/babel-plugin",
  {
    "factories": ["path/here"]
  }
]
```

* Type: `string[]`
* Factories can have any number of arguments.
* Factories can create any number of units.
* Factories can call any effector methods.
* Factories can call other factories from other modules.
* Modules with factories can export any number of functions.
* Factories should be compiled with `effector/babel-plugin` as well as code which use them.

#### Examples

```json
// .babelrc
{
  "plugins": [
    [
      "effector/babel-plugin",
      {
        "factories": ["src/createEffectStatus", "~/createCommonPending"]
      }
    ]
  ]
}
```

```js
// ./src/createEffectStatus.js
import { rootDomain } from "./rootDomain";

export function createEffectStatus(fx) {
  const $status = rootDomain.createStore("init").on(fx.finally, (_, { status }) => status);

  return $status;
}
```

```js
// ./src/statuses.js
import { createEffectStatus } from "./createEffectStatus";
import { fetchUserFx, fetchFriendsFx } from "./api";

export const $fetchUserStatus = createEffectStatus(fetchUserFx);
export const $fetchFriendsStatus = createEffectStatus(fetchFriendsFx);
```

Import `createEffectStatus` from `'./createEffectStatus'` was treated as factory function, so each store created by it
has its own sid and will be handled by serialize
independently, although without `factories` they will share the same `sid`.

### `reactSsr`

Replaces imports from `effector-react` to `effector-react/scope`. Useful for building both server-side and client-side
builds from the same codebase.

> WARNING Deprecated: 
>
> Since [effector 23.0.0](https://changelog.effector.dev/#effector-23-0-0) the core team recommends deleting this option from `babel-plugin` configuration because effector-react supports SSR by default.

#### Formulae

```json
[
  "effector/babel-plugin",
  {
    "reactSsr": false
  }
]
```

* Type: `boolean`
* Default: `false`

### `addNames`

Adds name to units factories call. Useful for minification and obfuscation of production builds.

> INFO since: 
>
> [effector 21.8.0](https://changelog.effector.dev/#effector-21-8-0)

#### Formulae

```json
[
  "effector/babel-plugin",
  {
    "addNames": true
  }
]
```

* Type: `boolean`
* Default: `true`

### `addLoc`

Adds location to methods' calls. Used by devtools, for example [effector-logger](https://github.com/effector/logger).

#### Formulae

```json
[
  "effector/babel-plugin",
  {
    "addLoc": false
  }
]
```

* Type: `boolean`
* Default: `false`

### `debugSids`

Adds a file path and variable name of a unit definition to a sid. Useful for debugging SSR.

#### Formulae

```json
[
  "effector/babel-plugin",
  {
    "debugSids": false
  }
]
```

* Type: `boolean`
* Default: `false`

### `transformLegacyDomainMethods`

Allows disabling transforming Unit creators on Domain. This option is useful when these transforms interfere with other libraries or your code.

The `effector/babel-plugin` may misidentify calls to unit creators because it is hard to know which variables are indeed Domains. If your project can't run due to this, you can turn these transforms off with this flag and pass `Domain` as an argument to regular unit creators, which is a better and more stable alternative.

> WARNING: 
>
> Disabling this option will prevent units created with `Domain` methods from having a `sid` and other information. If your code relies on these methods, this will cause issues with your existing code.

#### Formulae

```json
[
  "effector/babel-plugin",
  {
    "transformLegacyDomainMethods": false
  }
]
```

* Type: `boolean`
* Default: `true`

### `noDefaults`

Option for `effector/babel-plugin` for making custom unit factories with clean configuration.

> INFO since: 
>
> [effector 20.2.0](https://changelog.effector.dev/#effector-20-2-0)

#### Formulae

```json
[
  "effector/babel-plugin",
  {
    "noDefaults": false
  }
]
```

* Type: `boolean`
* Default: `false`

#### Examples

```json
// .babelrc
{
  "plugins": [
    ["effector/babel-plugin", { "addLoc": true }],
    [
      "effector/babel-plugin",
      {
        "importName": "@lib/createInputField",
        "storeCreators": ["createInputField"],
        "noDefaults": true
      },
      "createInputField"
    ]
  ]
}
```

```js
// @lib/createInputField.js
import { createStore } from "effector";
import { resetForm } from "./form";

export function createInputField(defaultState, { sid, name }) {
  return createStore(defaultState, { sid, name }).reset(resetForm);
}
```

```js
// src/state.js
import { createInputField } from "@lib/createInputField";

const foo = createInputField("-");
/*

will be treated as store creator and compiled to

const foo = createInputField('-', {
  name: 'foo',
  sid: 'z&si65'
})

*/
```

## Usage with Bundlers

### Vite + React (SSR)

To use with `effector/babel-plugin`, you have to following next steps:

1. Install `@vitejs/plugin-react` package.
2. `vite.config.js` should be follows:

> Note: `effector/babel-plugin` is not a package, it is bundled with `effector`

```js
// vite.config.js
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [
    react({
      babel: {
        plugins: ["effector/babel-plugin"],
        // Use .babelrc files
        babelrc: true,
        // Use babel.config.js files
        configFile: true,
      },
    }),
  ],
});
```
